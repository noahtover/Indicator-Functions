# This function identifies bullish and bearish engulfing candles by determining if the current candle is a specificed % larger than the previous one.
# An engulfing candle is a positive candlestick than is significantly larger than the previous negative candlestick.
engulfing_candle <- function(x, pct_change = .04){
 if(is.OC(x) == FALSE)
   stop('This function requires the open and close columns!')
  lags <- stats::lag(OHLC(x))
  pct_diff <- ((Cl(x) - Op(x)) - (Op(lags) - Cl(lags))) / (Op(lags) - Cl(lags))
  bearish_pct_diff <- ((Op(x) - Cl(x)) - (Cl(lags) - Op(lags))) / (Cl(lags) - Op(lags))
  bullish_engulfing <- ifelse(Op(lags) > Cl(lags) & Op(x) < Cl(x) & pct_diff >= pct_change, yes = TRUE, no = FALSE)
  bearish_engulfing <- ifelse(Op(lags) < Cl(lags) & Op(x) > Cl(x) & bearish_pct_diff >= pct_change, yes = TRUE, no = FALSE)
  engulfing <- cbind(bullish_engulfing, bearish_engulfing)
  colnames(engulfing) <- c('bullish_engulfing', 'bearish_engulfing')
  return(engulfing)
}
########################################
# This function identifies a series of consecutive green (positive) or red (negative) candlesticks. The count argument specifies the number of consecutive candles to search for.
consecutive_candles <- function(x, count = 3, type = c('green', 'red')){
  if(is.OC(x) == FALSE){
    stop('This function requires the open and close columns!')
  }
  count <- count - 1
  lags <- stats::lag(OHLC(x), k = 0:count)
  opens <- Op(lags)
  closes <- Cl(lags)
  diff <- opens - closes
  if(type == 'green'){
    diff$greenconsecutive <- NA
      for(i in 1:nrow(diff)){
        diff[i, 'greenconsecutive'] <- all(diff[i, 1:ncol(diff) - 1] < 0)
      }
    greenconsecutive <- ifelse(diff$greenconsecutive == 1, yes = TRUE, no = FALSE)
    return(greenconsecutive)
  }
  if(type == 'red'){
    diff$redconsecutive <- NA
      for(i in 1:nrow(diff)){
        diff[i, 'redconsecutive'] <- all(diff[i, 1:ncol(diff) - 1] > 0)
      }
    redconsecutive <- ifelse(diff$redconsecutive == 1, yes = TRUE, no = FALSE)
    return(redconsecutive)
  }
}
############################################
# This function builds off the trend direction channel indicator of the candlesticks package. It utilizes the donachion channel to identify trending & ranging markets
# The indicator I built improves upon it by finding the percent of signals produced for each trend in the past n days. 
library(candlesticks)
direction_confidence <- function(x, n = 30, testlookback = 126, DCSector = 1/8){
  trend_test <- TrendDetectionChannel(TS = OHLC(x), n = testlookback, DCSector = DCSector)
  upsums <- runSum(trend_test$UpTrend, n = n)
  downsums <- runSum(trend_test$DownTrend, n = n)
  nosums <- runSum(trend_test$NoTrend, n = n)
  uptrend <- upsums / n
  downtrend <- downsums / n
  notrend <- nosums / n
  confidence <- cbind(uptrend, notrend, downtrend)
  colnames(confidence) <- c('uptrend', 'downtrend', 'notrend')
  return(confidence)
}
############################################
